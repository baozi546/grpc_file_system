// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: define.proto
#ifndef GRPC_define_2eproto__INCLUDED
#define GRPC_define_2eproto__INCLUDED

#include "define.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace file_system {

class AuthService final {
 public:
  static constexpr char const* service_full_name() {
    return "file_system.AuthService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 用户登录获取Token.
    virtual ::grpc::Status Login(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::file_system::OperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>> AsyncLogin(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    // 权限验证（元数据中携带Token）.
    virtual ::grpc::Status CheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::file_system::PermissionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::PermissionResponse>> AsyncCheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::PermissionResponse>>(AsyncCheckPermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::PermissionResponse>> PrepareAsyncCheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::PermissionResponse>>(PrepareAsyncCheckPermissionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // 用户登录获取Token.
      virtual void Login(::grpc::ClientContext* context, const ::file_system::LoginRequest* request, ::file_system::OperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Login(::grpc::ClientContext* context, const ::file_system::LoginRequest* request, ::file_system::OperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 权限验证（元数据中携带Token）.
      virtual void CheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest* request, ::file_system::PermissionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest* request, ::file_system::PermissionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>* AsyncLoginRaw(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::PermissionResponse>* AsyncCheckPermissionRaw(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::PermissionResponse>* PrepareAsyncCheckPermissionRaw(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Login(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::file_system::OperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>> AsyncLogin(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    ::grpc::Status CheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::file_system::PermissionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::PermissionResponse>> AsyncCheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::PermissionResponse>>(AsyncCheckPermissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::PermissionResponse>> PrepareAsyncCheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::PermissionResponse>>(PrepareAsyncCheckPermissionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Login(::grpc::ClientContext* context, const ::file_system::LoginRequest* request, ::file_system::OperationResponse* response, std::function<void(::grpc::Status)>) override;
      void Login(::grpc::ClientContext* context, const ::file_system::LoginRequest* request, ::file_system::OperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest* request, ::file_system::PermissionResponse* response, std::function<void(::grpc::Status)>) override;
      void CheckPermission(::grpc::ClientContext* context, const ::file_system::PermissionRequest* request, ::file_system::PermissionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>* AsyncLoginRaw(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::file_system::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::PermissionResponse>* AsyncCheckPermissionRaw(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::PermissionResponse>* PrepareAsyncCheckPermissionRaw(::grpc::ClientContext* context, const ::file_system::PermissionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Login_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckPermission_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 用户登录获取Token.
    virtual ::grpc::Status Login(::grpc::ServerContext* context, const ::file_system::LoginRequest* request, ::file_system::OperationResponse* response);
    // 权限验证（元数据中携带Token）.
    virtual ::grpc::Status CheckPermission(::grpc::ServerContext* context, const ::file_system::PermissionRequest* request, ::file_system::PermissionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Login() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::file_system::LoginRequest* request, ::grpc::ServerAsyncResponseWriter< ::file_system::OperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckPermission() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CheckPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckPermission(::grpc::ServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckPermission(::grpc::ServerContext* context, ::file_system::PermissionRequest* request, ::grpc::ServerAsyncResponseWriter< ::file_system::PermissionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Login<WithAsyncMethod_CheckPermission<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Login() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::file_system::LoginRequest, ::file_system::OperationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::LoginRequest* request, ::file_system::OperationResponse* response) { return this->Login(context, request, response); }));}
    void SetMessageAllocatorFor_Login(
        ::grpc::MessageAllocator< ::file_system::LoginRequest, ::file_system::OperationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::file_system::LoginRequest, ::file_system::OperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckPermission() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::file_system::PermissionRequest, ::file_system::PermissionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::PermissionRequest* request, ::file_system::PermissionResponse* response) { return this->CheckPermission(context, request, response); }));}
    void SetMessageAllocatorFor_CheckPermission(
        ::grpc::MessageAllocator< ::file_system::PermissionRequest, ::file_system::PermissionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::file_system::PermissionRequest, ::file_system::PermissionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckPermission(::grpc::ServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckPermission(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Login<WithCallbackMethod_CheckPermission<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Login() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckPermission() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CheckPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckPermission(::grpc::ServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Login() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckPermission() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CheckPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckPermission(::grpc::ServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckPermission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Login() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Login(context, request, response); }));
    }
    ~WithRawCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckPermission() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckPermission(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckPermission(::grpc::ServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckPermission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Login() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::file_system::LoginRequest, ::file_system::OperationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::file_system::LoginRequest, ::file_system::OperationResponse>* streamer) {
                       return this->StreamedLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::file_system::LoginRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::file_system::LoginRequest,::file_system::OperationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckPermission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckPermission() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::file_system::PermissionRequest, ::file_system::PermissionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::file_system::PermissionRequest, ::file_system::PermissionResponse>* streamer) {
                       return this->StreamedCheckPermission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckPermission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckPermission(::grpc::ServerContext* /*context*/, const ::file_system::PermissionRequest* /*request*/, ::file_system::PermissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckPermission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::file_system::PermissionRequest,::file_system::PermissionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_CheckPermission<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_CheckPermission<Service > > StreamedService;
};

class FileService final {
 public:
  static constexpr char const* service_full_name() {
    return "file_system.FileService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status FileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::file_system::OperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>> AsyncFileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>>(AsyncFileOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>> PrepareAsyncFileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>>(PrepareAsyncFileOperationRaw(context, request, cq));
    }
    virtual ::grpc::Status UploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::file_system::UploadFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadFileResponse>> AsyncUploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadFileResponse>>(AsyncUploadFileRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadFileResponse>> PrepareAsyncUploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadFileResponse>>(PrepareAsyncUploadFileRequestRaw(context, request, cq));
    }
    // 客户端流式上传（支持断点续传）.
    std::unique_ptr< ::grpc::ClientWriterInterface< ::file_system::FileChunk>> UploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::file_system::FileChunk>>(UploadFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::file_system::FileChunk>> AsyncUploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::file_system::FileChunk>>(AsyncUploadFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::file_system::FileChunk>> PrepareAsyncUploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::file_system::FileChunk>>(PrepareAsyncUploadFileRaw(context, response, cq));
    }
    // 服务端流式下载.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::file_system::FileChunk>> DownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::file_system::FileChunk>>(DownloadFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileChunk>> AsyncDownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileChunk>>(AsyncDownloadFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileChunk>> PrepareAsyncDownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileChunk>>(PrepareAsyncDownloadFileRaw(context, request, cq));
    }
    // 查询上传断点状态.
    virtual ::grpc::Status CheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::file_system::UploadStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadStatus>> AsyncCheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadStatus>>(AsyncCheckUploadStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadStatus>> PrepareAsyncCheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadStatus>>(PrepareAsyncCheckUploadStatusRaw(context, request, cq));
    }
    // 合并请求.
    virtual ::grpc::Status MergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::file_system::OperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>> AsyncMergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>>(AsyncMergeChunkRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>> PrepareAsyncMergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>>(PrepareAsyncMergeChunkRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::file_system::FileMetadata>> FindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::file_system::FileMetadata>>(FindFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileMetadata>> AsyncFindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileMetadata>>(AsyncFindFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileMetadata>> PrepareAsyncFindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::file_system::FileMetadata>>(PrepareAsyncFindFileRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void FileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest* request, ::file_system::OperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest* request, ::file_system::OperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端流式上传（支持断点续传）.
      virtual void UploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::ClientWriteReactor< ::file_system::FileChunk>* reactor) = 0;
      // 服务端流式下载.
      virtual void DownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest* request, ::grpc::ClientReadReactor< ::file_system::FileChunk>* reactor) = 0;
      // 查询上传断点状态.
      virtual void CheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 合并请求.
      virtual void MergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::OperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::OperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void FindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest* request, ::grpc::ClientReadReactor< ::file_system::FileMetadata>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>* AsyncFileOperationRaw(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>* PrepareAsyncFileOperationRaw(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadFileResponse>* AsyncUploadFileRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadFileResponse>* PrepareAsyncUploadFileRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::file_system::FileChunk>* UploadFileRaw(::grpc::ClientContext* context, ::file_system::UploadStatus* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::file_system::FileChunk>* AsyncUploadFileRaw(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::file_system::FileChunk>* PrepareAsyncUploadFileRaw(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::file_system::FileChunk>* DownloadFileRaw(::grpc::ClientContext* context, const ::file_system::FileRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::file_system::FileChunk>* AsyncDownloadFileRaw(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::file_system::FileChunk>* PrepareAsyncDownloadFileRaw(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadStatus>* AsyncCheckUploadStatusRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::UploadStatus>* PrepareAsyncCheckUploadStatusRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>* AsyncMergeChunkRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::file_system::OperationResponse>* PrepareAsyncMergeChunkRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::file_system::FileMetadata>* FindFileRaw(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::file_system::FileMetadata>* AsyncFindFileRaw(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::file_system::FileMetadata>* PrepareAsyncFindFileRaw(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status FileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::file_system::OperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>> AsyncFileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>>(AsyncFileOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>> PrepareAsyncFileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>>(PrepareAsyncFileOperationRaw(context, request, cq));
    }
    ::grpc::Status UploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::file_system::UploadFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadFileResponse>> AsyncUploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadFileResponse>>(AsyncUploadFileRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadFileResponse>> PrepareAsyncUploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadFileResponse>>(PrepareAsyncUploadFileRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::file_system::FileChunk>> UploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::file_system::FileChunk>>(UploadFileRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::file_system::FileChunk>> AsyncUploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::file_system::FileChunk>>(AsyncUploadFileRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::file_system::FileChunk>> PrepareAsyncUploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::file_system::FileChunk>>(PrepareAsyncUploadFileRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::file_system::FileChunk>> DownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::file_system::FileChunk>>(DownloadFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileChunk>> AsyncDownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileChunk>>(AsyncDownloadFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileChunk>> PrepareAsyncDownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileChunk>>(PrepareAsyncDownloadFileRaw(context, request, cq));
    }
    ::grpc::Status CheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::file_system::UploadStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadStatus>> AsyncCheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadStatus>>(AsyncCheckUploadStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadStatus>> PrepareAsyncCheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::UploadStatus>>(PrepareAsyncCheckUploadStatusRaw(context, request, cq));
    }
    ::grpc::Status MergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::file_system::OperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>> AsyncMergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>>(AsyncMergeChunkRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>> PrepareAsyncMergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>>(PrepareAsyncMergeChunkRequestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::file_system::FileMetadata>> FindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::file_system::FileMetadata>>(FindFileRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileMetadata>> AsyncFindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileMetadata>>(AsyncFindFileRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileMetadata>> PrepareAsyncFindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::file_system::FileMetadata>>(PrepareAsyncFindFileRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void FileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest* request, ::file_system::OperationResponse* response, std::function<void(::grpc::Status)>) override;
      void FileOperation(::grpc::ClientContext* context, const ::file_system::FileOperationRequest* request, ::file_system::OperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadFileResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadFileRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadFile(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::ClientWriteReactor< ::file_system::FileChunk>* reactor) override;
      void DownloadFile(::grpc::ClientContext* context, const ::file_system::FileRequest* request, ::grpc::ClientReadReactor< ::file_system::FileChunk>* reactor) override;
      void CheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadStatus* response, std::function<void(::grpc::Status)>) override;
      void CheckUploadStatus(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      void MergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::OperationResponse* response, std::function<void(::grpc::Status)>) override;
      void MergeChunkRequest(::grpc::ClientContext* context, const ::file_system::FileMetadata* request, ::file_system::OperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FindFile(::grpc::ClientContext* context, const ::file_system::FindFileRequest* request, ::grpc::ClientReadReactor< ::file_system::FileMetadata>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>* AsyncFileOperationRaw(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>* PrepareAsyncFileOperationRaw(::grpc::ClientContext* context, const ::file_system::FileOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::UploadFileResponse>* AsyncUploadFileRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::UploadFileResponse>* PrepareAsyncUploadFileRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::file_system::FileChunk>* UploadFileRaw(::grpc::ClientContext* context, ::file_system::UploadStatus* response) override;
    ::grpc::ClientAsyncWriter< ::file_system::FileChunk>* AsyncUploadFileRaw(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::file_system::FileChunk>* PrepareAsyncUploadFileRaw(::grpc::ClientContext* context, ::file_system::UploadStatus* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::file_system::FileChunk>* DownloadFileRaw(::grpc::ClientContext* context, const ::file_system::FileRequest& request) override;
    ::grpc::ClientAsyncReader< ::file_system::FileChunk>* AsyncDownloadFileRaw(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::file_system::FileChunk>* PrepareAsyncDownloadFileRaw(::grpc::ClientContext* context, const ::file_system::FileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::UploadStatus>* AsyncCheckUploadStatusRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::UploadStatus>* PrepareAsyncCheckUploadStatusRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>* AsyncMergeChunkRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::file_system::OperationResponse>* PrepareAsyncMergeChunkRequestRaw(::grpc::ClientContext* context, const ::file_system::FileMetadata& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::file_system::FileMetadata>* FindFileRaw(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request) override;
    ::grpc::ClientAsyncReader< ::file_system::FileMetadata>* AsyncFindFileRaw(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::file_system::FileMetadata>* PrepareAsyncFindFileRaw(::grpc::ClientContext* context, const ::file_system::FindFileRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_FileOperation_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadFileRequest_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadFile_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadFile_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckUploadStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_MergeChunkRequest_;
    const ::grpc::internal::RpcMethod rpcmethod_FindFile_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status FileOperation(::grpc::ServerContext* context, const ::file_system::FileOperationRequest* request, ::file_system::OperationResponse* response);
    virtual ::grpc::Status UploadFileRequest(::grpc::ServerContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadFileResponse* response);
    // 客户端流式上传（支持断点续传）.
    virtual ::grpc::Status UploadFile(::grpc::ServerContext* context, ::grpc::ServerReader< ::file_system::FileChunk>* reader, ::file_system::UploadStatus* response);
    // 服务端流式下载.
    virtual ::grpc::Status DownloadFile(::grpc::ServerContext* context, const ::file_system::FileRequest* request, ::grpc::ServerWriter< ::file_system::FileChunk>* writer);
    // 查询上传断点状态.
    virtual ::grpc::Status CheckUploadStatus(::grpc::ServerContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadStatus* response);
    // 合并请求.
    virtual ::grpc::Status MergeChunkRequest(::grpc::ServerContext* context, const ::file_system::FileMetadata* request, ::file_system::OperationResponse* response);
    virtual ::grpc::Status FindFile(::grpc::ServerContext* context, const ::file_system::FindFileRequest* request, ::grpc::ServerWriter< ::file_system::FileMetadata>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_FileOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FileOperation() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_FileOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileOperation(::grpc::ServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileOperation(::grpc::ServerContext* context, ::file_system::FileOperationRequest* request, ::grpc::ServerAsyncResponseWriter< ::file_system::OperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadFileRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadFileRequest() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_UploadFileRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFileRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadFileRequest(::grpc::ServerContext* context, ::file_system::FileMetadata* request, ::grpc::ServerAsyncResponseWriter< ::file_system::UploadFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadFile() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::file_system::FileChunk>* /*reader*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::file_system::UploadStatus, ::file_system::FileChunk>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadFile() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DownloadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadFile(::grpc::ServerContext* /*context*/, const ::file_system::FileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadFile(::grpc::ServerContext* context, ::file_system::FileRequest* request, ::grpc::ServerAsyncWriter< ::file_system::FileChunk>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckUploadStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckUploadStatus() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CheckUploadStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckUploadStatus(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckUploadStatus(::grpc::ServerContext* context, ::file_system::FileMetadata* request, ::grpc::ServerAsyncResponseWriter< ::file_system::UploadStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MergeChunkRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MergeChunkRequest() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_MergeChunkRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeChunkRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMergeChunkRequest(::grpc::ServerContext* context, ::file_system::FileMetadata* request, ::grpc::ServerAsyncResponseWriter< ::file_system::OperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FindFile() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_FindFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindFile(::grpc::ServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileMetadata>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindFile(::grpc::ServerContext* context, ::file_system::FindFileRequest* request, ::grpc::ServerAsyncWriter< ::file_system::FileMetadata>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_FileOperation<WithAsyncMethod_UploadFileRequest<WithAsyncMethod_UploadFile<WithAsyncMethod_DownloadFile<WithAsyncMethod_CheckUploadStatus<WithAsyncMethod_MergeChunkRequest<WithAsyncMethod_FindFile<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_FileOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FileOperation() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::file_system::FileOperationRequest, ::file_system::OperationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::FileOperationRequest* request, ::file_system::OperationResponse* response) { return this->FileOperation(context, request, response); }));}
    void SetMessageAllocatorFor_FileOperation(
        ::grpc::MessageAllocator< ::file_system::FileOperationRequest, ::file_system::OperationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::file_system::FileOperationRequest, ::file_system::OperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FileOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileOperation(::grpc::ServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FileOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadFileRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadFileRequest() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::file_system::FileMetadata, ::file_system::UploadFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadFileResponse* response) { return this->UploadFileRequest(context, request, response); }));}
    void SetMessageAllocatorFor_UploadFileRequest(
        ::grpc::MessageAllocator< ::file_system::FileMetadata, ::file_system::UploadFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::file_system::FileMetadata, ::file_system::UploadFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadFileRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFileRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadFileRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadFile() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackClientStreamingHandler< ::file_system::FileChunk, ::file_system::UploadStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, ::file_system::UploadStatus* response) { return this->UploadFile(context, response); }));
    }
    ~WithCallbackMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::file_system::FileChunk>* /*reader*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::file_system::FileChunk>* UploadFile(
      ::grpc::CallbackServerContext* /*context*/, ::file_system::UploadStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadFile() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::file_system::FileRequest, ::file_system::FileChunk>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::FileRequest* request) { return this->DownloadFile(context, request); }));
    }
    ~WithCallbackMethod_DownloadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadFile(::grpc::ServerContext* /*context*/, const ::file_system::FileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::file_system::FileChunk>* DownloadFile(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::FileRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckUploadStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckUploadStatus() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::file_system::FileMetadata, ::file_system::UploadStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::FileMetadata* request, ::file_system::UploadStatus* response) { return this->CheckUploadStatus(context, request, response); }));}
    void SetMessageAllocatorFor_CheckUploadStatus(
        ::grpc::MessageAllocator< ::file_system::FileMetadata, ::file_system::UploadStatus>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::file_system::FileMetadata, ::file_system::UploadStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckUploadStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckUploadStatus(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckUploadStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_MergeChunkRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_MergeChunkRequest() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::file_system::FileMetadata, ::file_system::OperationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::FileMetadata* request, ::file_system::OperationResponse* response) { return this->MergeChunkRequest(context, request, response); }));}
    void SetMessageAllocatorFor_MergeChunkRequest(
        ::grpc::MessageAllocator< ::file_system::FileMetadata, ::file_system::OperationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::file_system::FileMetadata, ::file_system::OperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_MergeChunkRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeChunkRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MergeChunkRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FindFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FindFile() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::file_system::FindFileRequest, ::file_system::FileMetadata>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::file_system::FindFileRequest* request) { return this->FindFile(context, request); }));
    }
    ~WithCallbackMethod_FindFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindFile(::grpc::ServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileMetadata>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::file_system::FileMetadata>* FindFile(
      ::grpc::CallbackServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_FileOperation<WithCallbackMethod_UploadFileRequest<WithCallbackMethod_UploadFile<WithCallbackMethod_DownloadFile<WithCallbackMethod_CheckUploadStatus<WithCallbackMethod_MergeChunkRequest<WithCallbackMethod_FindFile<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_FileOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FileOperation() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_FileOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileOperation(::grpc::ServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadFileRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadFileRequest() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_UploadFileRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFileRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadFile() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::file_system::FileChunk>* /*reader*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadFile() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DownloadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadFile(::grpc::ServerContext* /*context*/, const ::file_system::FileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckUploadStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckUploadStatus() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CheckUploadStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckUploadStatus(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MergeChunkRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MergeChunkRequest() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_MergeChunkRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeChunkRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FindFile() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_FindFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindFile(::grpc::ServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileMetadata>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_FileOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FileOperation() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_FileOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileOperation(::grpc::ServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileOperation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadFileRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadFileRequest() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_UploadFileRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFileRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadFileRequest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadFile() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::file_system::FileChunk>* /*reader*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadFile(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadFile() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DownloadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadFile(::grpc::ServerContext* /*context*/, const ::file_system::FileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckUploadStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckUploadStatus() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CheckUploadStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckUploadStatus(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckUploadStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MergeChunkRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MergeChunkRequest() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_MergeChunkRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeChunkRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMergeChunkRequest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FindFile() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_FindFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindFile(::grpc::ServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileMetadata>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FileOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FileOperation() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FileOperation(context, request, response); }));
    }
    ~WithRawCallbackMethod_FileOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileOperation(::grpc::ServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FileOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadFileRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadFileRequest() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadFileRequest(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadFileRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFileRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadFileRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadFile() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->UploadFile(context, response); }));
    }
    ~WithRawCallbackMethod_UploadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadFile(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::file_system::FileChunk>* /*reader*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* UploadFile(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadFile() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->DownloadFile(context, request); }));
    }
    ~WithRawCallbackMethod_DownloadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadFile(::grpc::ServerContext* /*context*/, const ::file_system::FileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DownloadFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckUploadStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckUploadStatus() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckUploadStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckUploadStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckUploadStatus(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckUploadStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_MergeChunkRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_MergeChunkRequest() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MergeChunkRequest(context, request, response); }));
    }
    ~WithRawCallbackMethod_MergeChunkRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeChunkRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* MergeChunkRequest(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FindFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FindFile() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->FindFile(context, request); }));
    }
    ~WithRawCallbackMethod_FindFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindFile(::grpc::ServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileMetadata>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* FindFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FileOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FileOperation() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::file_system::FileOperationRequest, ::file_system::OperationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::file_system::FileOperationRequest, ::file_system::OperationResponse>* streamer) {
                       return this->StreamedFileOperation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FileOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FileOperation(::grpc::ServerContext* /*context*/, const ::file_system::FileOperationRequest* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFileOperation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::file_system::FileOperationRequest,::file_system::OperationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadFileRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadFileRequest() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::file_system::FileMetadata, ::file_system::UploadFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::file_system::FileMetadata, ::file_system::UploadFileResponse>* streamer) {
                       return this->StreamedUploadFileRequest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadFileRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadFileRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadFileRequest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::file_system::FileMetadata,::file_system::UploadFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckUploadStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckUploadStatus() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::file_system::FileMetadata, ::file_system::UploadStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::file_system::FileMetadata, ::file_system::UploadStatus>* streamer) {
                       return this->StreamedCheckUploadStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckUploadStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckUploadStatus(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::UploadStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckUploadStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::file_system::FileMetadata,::file_system::UploadStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MergeChunkRequest : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MergeChunkRequest() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::file_system::FileMetadata, ::file_system::OperationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::file_system::FileMetadata, ::file_system::OperationResponse>* streamer) {
                       return this->StreamedMergeChunkRequest(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MergeChunkRequest() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MergeChunkRequest(::grpc::ServerContext* /*context*/, const ::file_system::FileMetadata* /*request*/, ::file_system::OperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMergeChunkRequest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::file_system::FileMetadata,::file_system::OperationResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_FileOperation<WithStreamedUnaryMethod_UploadFileRequest<WithStreamedUnaryMethod_CheckUploadStatus<WithStreamedUnaryMethod_MergeChunkRequest<Service > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_DownloadFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DownloadFile() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::file_system::FileRequest, ::file_system::FileChunk>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::file_system::FileRequest, ::file_system::FileChunk>* streamer) {
                       return this->StreamedDownloadFile(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DownloadFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadFile(::grpc::ServerContext* /*context*/, const ::file_system::FileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileChunk>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDownloadFile(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::file_system::FileRequest,::file_system::FileChunk>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_FindFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_FindFile() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::file_system::FindFileRequest, ::file_system::FileMetadata>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::file_system::FindFileRequest, ::file_system::FileMetadata>* streamer) {
                       return this->StreamedFindFile(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_FindFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindFile(::grpc::ServerContext* /*context*/, const ::file_system::FindFileRequest* /*request*/, ::grpc::ServerWriter< ::file_system::FileMetadata>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedFindFile(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::file_system::FindFileRequest,::file_system::FileMetadata>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_DownloadFile<WithSplitStreamingMethod_FindFile<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_FileOperation<WithStreamedUnaryMethod_UploadFileRequest<WithSplitStreamingMethod_DownloadFile<WithStreamedUnaryMethod_CheckUploadStatus<WithStreamedUnaryMethod_MergeChunkRequest<WithSplitStreamingMethod_FindFile<Service > > > > > > StreamedService;
};

}  // namespace file_system


#endif  // GRPC_define_2eproto__INCLUDED
